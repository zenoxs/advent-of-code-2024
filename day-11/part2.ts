import * as path from "jsr:@std/path"

const inputPath = path.join(import.meta.dirname!, "input.txt")
const inputs = await Deno.readTextFile(inputPath)

const stones = inputs.split(" ").map((v) => parseInt(v, 10))

// Cache that store the number of stone generated by a stone based on its value then blinkTime
const caches: Record<number, Record<number, number | undefined> | undefined> = {}

function evaluateStone(stone: number, maxBlinkTime: number, blinkTime: number = 0): number {
    // Check if the stone is present in the cache
    if (caches[stone]?.[blinkTime]) {
        return caches[stone]?.[blinkTime]
    }

    let nextValue: number
    const stoneStr = stone.toString()

    // Otherwise calculate the number of stone generated
    if (blinkTime === maxBlinkTime) {
        nextValue = 1
    } else if (stone === 0) {
        nextValue = evaluateStone(1, maxBlinkTime, blinkTime + 1)
    } else if (stoneStr.length % 2 === 0) {
        const mid = Math.ceil(stoneStr.length / 2)
        const newStoneLeft = parseInt(stoneStr.slice(0, mid), 10)
        const newStoneRight = parseInt(stoneStr.slice(mid), 10)

        nextValue = evaluateStone(newStoneLeft, maxBlinkTime, blinkTime + 1) +
            evaluateStone(newStoneRight, maxBlinkTime, blinkTime + 1)
    } else {
        nextValue = evaluateStone(stone * 2024, maxBlinkTime, blinkTime + 1)
    }

    // Store the recursive value in the cache
    if (!caches[stone]) {
        caches[stone] = {}
    }

    caches[stone][blinkTime] = nextValue

    // Return the value
    return nextValue
}

const total = stones.reduce((acc, stone) => acc + evaluateStone(stone, 75), 0)

console.log(total)
